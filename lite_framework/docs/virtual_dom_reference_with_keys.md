# üß± Virtual DOM ‚Äî Complete Technical Reference

A **Virtual DOM (vDOM)** is a lightweight, in-memory representation of the real DOM.  
To build one, you must understand what makes up a DOM element and how to abstract it efficiently for comparison, rendering, and updating.

---

## üß© 1. Anatomy of a DOM Element

Every DOM element in the browser can have:

| Category | Examples | Description |
|-----------|-----------|-------------|
| **Tag name** | `"div"`, `"span"`, `"input"`, `"ul"`, `"custom-element"` | Defines the element type |
| **Attributes** | `id`, `class`, `src`, `alt`, `href`, `type` | Key‚Äìvalue pairs attached to the element |
| **Properties** | `checked`, `value`, `innerHTML`, `disabled` | Reflect internal element state; can differ from attributes |
| **Styles** | `style="color:red; font-size:16px"` | Inline or computed CSS |
| **Event listeners** | `onclick`, `oninput`, `onchange`, etc. | Event callbacks attached to the element |
| **Children** | `<div><p></p><p></p></div>` | Other DOM nodes nested inside |
| **Text content** | `"Hello World"` | Pure text nodes (no tag, only text) |
| **Refs / keys** | `key="unique-id"` | Used for efficient reconciliation |
| **Dataset** | `data-*` attributes | Custom attributes for application logic |

---

## üß± 2. Virtual DOM Node Structure

A **VNode (Virtual Node)** is a plain JavaScript object that mirrors a real DOM node.

```js
const vNode = {
  tag: "div",                      // Element tag name
  attrs: { id: "main", class: "app-container" }, // Attributes
  props: { value: "some data" },   // DOM properties
  style: { color: "red" },         // Inline styles
  events: {                        // Event listeners
    click: handleClick,
    input: handleInput
  },
  children: [                      // Nested nodes
    { tag: "h1", children: ["Hello World"] },
    "This is text content",
    { tag: "button", attrs: { id: "save" }, children: ["Save"] }
  ],
  key: "root"                      // Optional unique identifier
};
```

---

## üßÆ 3. Virtual Node Creation (`h` function)

The **`h` (hyperscript)** function is used to create Virtual DOM nodes easily.

```js
function h(tag, attrs = {}, ...children) {
  return {
    tag,
    key: attrs.key || null,
    attrs: attrs.attrs || {},
    props: attrs.props || {},
    style: attrs.style || {},
    events: attrs.events || {},
    children: children.flat()
  };
}
```

### Example Usage

```js
const app = h("div", { attrs: { id: "root" } },
  h("h1", {}, "Hello"),
  h("p", {}, "Welcome to my framework!")
);
```

---

## ‚öôÔ∏è 4. Diffing (Comparing Two Virtual DOMs)

The **diffing algorithm** compares an **old Virtual DOM** with a **new one**,  
and outputs a set of **patch instructions** to update the real DOM efficiently.

| Type of change | Example | How to handle |
|----------------|----------|---------------|
| Tag changed | `<div>` ‚Üí `<span>` | Replace node |
| Attribute changed | `class="a"` ‚Üí `class="b"` | Update attribute |
| Text changed | `"Hello"` ‚Üí `"Hi"` | Update textContent |
| Event changed | `onClick` changed | Remove old/add new listener |
| Children changed | Add/remove/reorder nodes | Reuse keyed nodes if possible |

### Simplified Diff Function

```js
function diff(oldNode, newNode) {
  if (!oldNode) return { type: "CREATE", newNode };
  if (!newNode) return { type: "REMOVE" };
  if (typeof oldNode === "string" || typeof newNode === "string") {
    if (oldNode !== newNode) return { type: "TEXT", newNode };
    return null;
  }
  if (oldNode.tag !== newNode.tag) return { type: "REPLACE", newNode };

  const attrPatches = diffAttrs(oldNode.attrs, newNode.attrs);
  const childPatches = diffChildren(oldNode.children, newNode.children);

  return { type: "UPDATE", attrPatches, childPatches };
}
```

---

## ü™Ñ 5. Patching (Applying Changes to Real DOM)

The **patch function** walks the real DOM and applies changes generated by `diff`.

```js
function patch(parent, patchObj, index = 0) {
  if (!patchObj) return;

  const element = parent.childNodes[index];

  switch (patchObj.type) {
    case "CREATE":
      parent.appendChild(render(patchObj.newNode));
      break;
    case "REMOVE":
      parent.removeChild(element);
      break;
    case "TEXT":
      element.textContent = patchObj.newNode;
      break;
    case "REPLACE":
      parent.replaceChild(render(patchObj.newNode), element);
      break;
    case "UPDATE":
      updateAttributes(element, patchObj.attrPatches);
      patchObj.childPatches.forEach((cp, i) => patch(element, cp, i));
      break;
  }
}
```

---

## üñºÔ∏è 6. Rendering (Virtual DOM ‚Üí Real DOM)

The **render** function converts a Virtual DOM tree into a real DOM tree.

```js
function render(vNode) {
  if (typeof vNode === "string") return document.createTextNode(vNode);

  const el = document.createElement(vNode.tag);

  // Apply attributes
  for (const [k, v] of Object.entries(vNode.attrs)) el.setAttribute(k, v);

  // Apply styles
  for (const [k, v] of Object.entries(vNode.style)) el.style[k] = v;

  // Bind event listeners
  for (const [event, handler] of Object.entries(vNode.events))
    el.addEventListener(event, handler);

  // Render and append children
  vNode.children.map(render).forEach(child => el.appendChild(child));

  return el;
}
```

---

## üß† 7. Advanced Framework Features

| Feature | Description |
|----------|--------------|
| **Keys** | Track list items for efficient reordering |
| **Components** | Functions that return Virtual DOMs (like React components) |
| **State Management** | Hooks or reactive system for re-renders |
| **Reconciliation Optimizations** | Skip unchanged subtrees |
| **Memoization** | Cache repeated computations |
| **Hydration** | Match server-rendered HTML with virtual DOM |

---

## üß© 8. Keys and Reconciliation

### What is a Key?

A **key** is a unique identifier for a Virtual DOM node. It tells the diffing algorithm which element corresponds to which previous element. Keys are essential for dynamic lists.

### Why Keys Affect Reconciliation

Reconciliation compares old and new Virtual DOM trees:
- **Without key**: Nodes are compared by **index**. Reordering items may cause unnecessary DOM updates, losing state and performance.
- **With key**: Nodes are matched by **identity**, preserving DOM elements and state even if order changes.

### Example Without Key

```js
const oldList = ["A", "B", "C"];
const newList = ["B", "A", "C"];
```
- Naive diff compares by index:
  - Index 0: A ‚Üí B (update text)
  - Index 1: B ‚Üí A (update text)
  - Index 2: C ‚Üí C (no change)
- Result: unnecessary updates and lost state.

### Example With Key

```js
const oldList = [
  { key: "A", value: "A" },
  { key: "B", value: "B" },
  { key: "C", value: "C" }
];
const newList = [
  { key: "B", value: "B" },
  { key: "A", value: "A" },
  { key: "C", value: "C" }
];
```
- Diff algorithm matches by `key`:
  - B ‚Üí B (reuse DOM node)
  - A ‚Üí A (reuse DOM node)
  - C ‚Üí C (reuse DOM node)
- Only DOM elements that are truly new or removed are created/removed.

### Key Rules

| Rule | Why it matters |
|------|----------------|
| Unique among siblings | Prevents mismatches |
| Stable across renders | Don't use index if items reorder |
| Not globally unique | Only unique within parent |
| Avoid random IDs each render | Breaks stability and forces re-renders |

### Diff Algorithm With Keys

```js
function diffChildren(oldChildren, newChildren) {
  const patches = [];
  const oldMap = new Map();

  oldChildren.forEach((child, i) => {
    if (child.key) oldMap.set(child.key, { child, index: i });
  });

  newChildren.forEach((newChild, i) => {
    const match = newChild.key ? oldMap.get(newChild.key) : null;
    if (match) {
      patches.push({ type: "UPDATE", index: match.index, newNode: newChild });
      oldMap.delete(newChild.key);
    } else {
      patches.push({ type: "CREATE", newNode: newChild });
    }
 

